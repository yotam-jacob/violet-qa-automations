{"version":3,"file":"commands.js","mappings":"4BAAO,MAAMA,EACJ,eAAOC,CAASC,GACrB,MAAwB,iBAAVA,CAChB,CAEO,oBAAOC,CAAcC,GAC1B,OAAOC,KAAKJ,SAASG,GAAWA,EAAUA,EAAQE,MACpD,CAEO,cAAOC,CAAQH,GACpB,OAAOC,KAAKJ,SAASG,GAAW,IAAII,OAAOJ,GAAWA,CACxD,CAEO,cAAOK,CAAQC,GACpB,MAAMC,EAAiBN,KAAKO,oBAAoBF,GAC1CG,EAAcR,KAAKQ,YAAYF,GAC/BF,EAAUE,EAAeG,UAAU,EAAGD,GAE5C,OAAOR,KAAKO,oBAAoBH,EAClC,CAEO,oBAAOM,CACZL,EACAM,G,MAEA,MAAMH,EAAcR,KAAKQ,YAAYH,GAC/BO,EAAOZ,KAAKa,mBAAmBR,EAAKI,UAAUD,IAE9CM,EAASF,EAAKG,YAAY,KAEhC,IAAIC,EACAC,EAAiBL,EAOrB,OALIE,GAAU,IACZE,EAAkB,QAAZ,EAAAL,aAAO,EAAPA,EAASK,WAAG,QAAIJ,EAAKH,UAAUK,GACrCG,EAAiBL,EAAKH,UAAU,EAAGK,IAG9B,GAAGG,IAAiBD,QAAAA,EAAO,QACpC,CAEO,uBAAOE,CACZC,EACAC,EAAgB,qBAEhB,IAAIC,GAAY,EAEhB,MAAMC,EAASF,EAAME,OAErB,IAAK,IAAIC,EAAI,EAAGA,EAAID,IAAUC,EAC5B,IAAsC,IAAlCJ,EAAIK,QAAQJ,EAAMK,OAAOF,IAAY,CACvCF,GAAY,EACZ,K,CAIJ,IAAKA,EACH,OAAOF,EAGT,IAAIO,EAAS,GAEb,IAAK,IAAIC,EAAI,EAAGA,EAAIR,EAAIG,SAAUK,GACM,IAAlCP,EAAMI,QAAQL,EAAIM,OAAOE,MAC3BD,GAAU,MAGZA,GAAUP,EAAIM,OAAOE,GAGvB,OAAOD,CACT,CAEQ,kBAAOlB,CAAYH,GACzB,OAAOA,EAAKmB,QAAQ,OAAS,EACzBnB,EAAKU,YAAY,MACjBV,EAAKU,YAAY,IACvB,CAEQ,yBAAOF,CAAmBR,GAChC,OAAOA,EAAKuB,QAAQ,UAAW,GACjC,CAEQ,0BAAOrB,CAAoBF,GACjC,OAAOA,EAAKuB,QAAQ,YAAa,GACnC,EClFFC,QAAQC,SAASC,IACf,aACCpB,I,QACC,OAAAqB,GAAGC,KAAK,YAAa,OAAF,sBACjBC,SAAS,EACTC,cAAc,EACdC,QAASzC,EAAYS,QAAQyB,QAAQQ,KAAKC,WACvC3B,GAAO,CACV4B,aAAmC,QAArB,EAAA5B,aAAO,EAAPA,EAAS4B,oBAAY,eAAEC,KAAIC,GACvC9C,EAAYG,cAAc2C,KAE5BC,aAAmC,QAArB,EAAA/B,aAAO,EAAPA,EAAS+B,oBAAY,eAAEF,KAAIC,GACvC9C,EAAYG,cAAc2C,OAE5B,IAGNZ,QAAQC,SAASC,IACf,WACCpB,I,QACC,MAAMgC,EAAmBd,QAAQQ,KAAKzB,KAChCgC,EAAgD,QAAtC,EAAAf,QAAQgB,IAAI,uBAA0B,QAAI,KAE1D,OAAOb,GAAGC,KAAK,UAAW,OAAF,sBACtBW,UACGjC,GAAO,CACVmC,SAAUnD,EAAYe,cACH,QAAjB,EAAAC,aAAO,EAAPA,EAASmC,gBAAQ,QAAIH,GACpBhC,aAAO,EAAPA,EAASmC,eAA6BC,EAAlB,CAAE/B,IAAK,WAE9B,IAINa,QAAQC,SAASC,IACf,gBACA,IAAyBC,GAAGC,KAAK,kB","sources":["webpack://@neuralegion/cypress-har-generator/./src/utils/StringUtils.ts","webpack://@neuralegion/cypress-har-generator/./src/commands.ts"],"sourcesContent":["export class StringUtils {\n  public static isString(value: unknown): value is string {\n    return typeof value === 'string';\n  }\n\n  public static toRegexSource(pattern: RegExp | string): string {\n    return this.isString(pattern) ? pattern : pattern.source;\n  }\n\n  public static toRegex(pattern: RegExp | string): RegExp {\n    return this.isString(pattern) ? new RegExp(pattern) : pattern;\n  }\n\n  public static dirname(path: string): string {\n    const normalizedPath = this.removeTrailingSlash(path);\n    const fileNameIdx = this.fileNameIdx(normalizedPath);\n    const dirname = normalizedPath.substring(0, fileNameIdx);\n\n    return this.removeTrailingSlash(dirname);\n  }\n\n  public static normalizeName(\n    path: string,\n    options?: { ext?: string }\n  ): string {\n    const fileNameIdx = this.fileNameIdx(path);\n    const name = this.removeLeadingSlash(path.substring(fileNameIdx));\n\n    const extIdx = name.lastIndexOf('.');\n\n    let ext: string | undefined;\n    let nameWithoutExt = name;\n\n    if (extIdx >= 0) {\n      ext = options?.ext ?? name.substring(extIdx);\n      nameWithoutExt = name.substring(0, extIdx);\n    }\n\n    return `${nameWithoutExt}${ext ?? '.har'}`;\n  }\n\n  public static escapeCharacters(\n    str: string,\n    chars: string = '^[]{}()\\\\\\\\.$*+?|'\n  ): string {\n    let foundChar = false;\n\n    const length = chars.length;\n\n    for (let i = 0; i < length; ++i) {\n      if (str.indexOf(chars.charAt(i)) !== -1) {\n        foundChar = true;\n        break;\n      }\n    }\n\n    if (!foundChar) {\n      return str;\n    }\n\n    let result = '';\n\n    for (let j = 0; j < str.length; ++j) {\n      if (chars.indexOf(str.charAt(j)) !== -1) {\n        result += '\\\\';\n      }\n\n      result += str.charAt(j);\n    }\n\n    return result;\n  }\n\n  private static fileNameIdx(path: string): number {\n    return path.indexOf('\\\\') >= 0\n      ? path.lastIndexOf('\\\\')\n      : path.lastIndexOf('/');\n  }\n\n  private static removeLeadingSlash(path: string): string {\n    return path.replace(/^\\/|^\\\\/, '');\n  }\n\n  private static removeTrailingSlash(path: string): string {\n    return path.replace(/\\/+$|\\\\+$/, '');\n  }\n}\n","import { StringUtils } from './utils/StringUtils';\nimport type { RecordOptions, SaveOptions } from './Plugin';\n\nCypress.Commands.add(\n  'recordHar',\n  (options?: Partial<RecordOptions>): Cypress.Chainable =>\n    cy.task('recordHar', {\n      content: true,\n      includeBlobs: true,\n      rootDir: StringUtils.dirname(Cypress.spec.absolute),\n      ...options,\n      excludePaths: options?.excludePaths?.map(x =>\n        StringUtils.toRegexSource(x)\n      ),\n      includeHosts: options?.includeHosts?.map(x =>\n        StringUtils.toRegexSource(x)\n      )\n    })\n);\n\nCypress.Commands.add(\n  'saveHar',\n  (options?: Partial<SaveOptions>): Cypress.Chainable => {\n    const fallbackFileName = Cypress.spec.name;\n    const outDir = (Cypress.env('hars_folders') as string) ?? './';\n\n    return cy.task('saveHar', {\n      outDir,\n      ...options,\n      fileName: StringUtils.normalizeName(\n        options?.fileName ?? fallbackFileName,\n        !options?.fileName ? { ext: '.har' } : undefined\n      )\n    });\n  }\n);\n\nCypress.Commands.add(\n  'disposeOfHar',\n  (): Cypress.Chainable => cy.task('disposeOfHar')\n);\n"],"names":["StringUtils","isString","value","toRegexSource","pattern","this","source","toRegex","RegExp","dirname","path","normalizedPath","removeTrailingSlash","fileNameIdx","substring","normalizeName","options","name","removeLeadingSlash","extIdx","lastIndexOf","ext","nameWithoutExt","escapeCharacters","str","chars","foundChar","length","i","indexOf","charAt","result","j","replace","Cypress","Commands","add","cy","task","content","includeBlobs","rootDir","spec","absolute","excludePaths","map","x","includeHosts","fallbackFileName","outDir","env","fileName","undefined"],"sourceRoot":""}